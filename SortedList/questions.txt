1. Дайте визначання колекції. Як колекція пов’язана з інтерфейсами
IEnumerable та ICollection?
    Колекція це певвна структура данних що зберігає дані у певний спосіб. Дані однакові
    але спосіб для кожної колекції вірдрізняеться. Всі колекції у c# їх імплементують.
    Інтерфейс ICollection наслідуе інтерфейс IEnumerable. Приклад Фішок які ці інтерфейси дають класам
    IEnumerable дозволяе використовувати foreach також багато різних інших методів будуть працювати на класах,
    що реалізували цей інтерфейс наприклад методи з LINQ як Where Add First ітд
    ICollection це базовий інтерфейс для усіх колекцій ну наприклад він дозволяе (метод Add) робити так
    var collection = new YourCollection<Item>() {Item a, Item b} тобто добавляти елементи при ініціалізації
2. Розкажіть про основні інтерфейси необхідні для функціонування
колекцій та LINQ.
    основні інтерфейси для функціювання колекцій це ICollection IList IDictionary
    для LINQ IQueryable (наслідуе IEnumerable) та QueryProvider (його повертае метод провайдер інтерфейсу Iqueryable)
    по простому: IQueariable ынтрефей що дозволяе робити LINQ запроси а провайдер забезпечуе що цы запроси будуть працювати
    там де потрібно (наприклад з EF XML обьектами тобто у різних середовищах)
3. Розкажіть про призначення і можливі сценарії застосування
    Основне призначення інтерфейсу IEnumerator це дозволяти перебрати дані класом значення
    Енумератор повинен мати T Current() bool MoveNext() та voidReset() але останній советують
    не імпоементувати і замість нього кидати NoImplementedException.
    Основний сценарій застосування це перебір значень за допомогою foreach та реалізація власної колекції
    у звичайному випадку його самостійно не імплементують а використовують синкасчний цукор ( ключове слово yield )
4. Порівняйте інтерфейси IEnumerable та IAsyncEnumerable.
    Асинхронний енумератор також використовуеться для перебору значень але вже працюе асинхронно
    Зазвичай вони використовуються в різних сценаріях: всинхронний енумратор використовуеться лише коли
    треба асинхронність зазвчивай це у мережевих операціях або у дуже ресурсоемких операціях які можуть тривати
    певний час. для перебору використовують await foreach (var varianle in someFunction()){ }
    він також має Current та MoveNextAsync Reset вже не мае для перебору використовуеться async foreach
    мінуси такіж як і у асинхронних функцій - потенційні проблеми з конкуренціею та складність також треба
    більше ресурсів тому краще використовувати тільк при потребі
5. Розкажіть про призначення і обмеження generic типів.
    Дженерікі (Generic Types) общі типи прийшли на заміну старому порядку тобто використанню класа object та
    запакування в нього та розпакування з нього. Само тому старі імплементації олекцій не мають женеріків
    і мають object. Основна проблема що вирішив дженерік тайп це те що ми будемо отримувати помилку не у
    рантаймі коли ми развернемо обжект а там не зрозмуло що і не зрозуміло чому воно там, а ми просто
    отримаемо помилку компілятора який скаже що це туди не підходить. Також це менше коду писать бо нам
    не треба обробляти анбоксинг та захищати його від помилок. Основним обмеженням е те що ми не знаемо
    що це за тип для нас це тип T або U (TU ітд) і тому по дефолту будуть лише доступні методи обжекста
    тобто ToString Equals ітд... І наприклад коли нам треба якийсь метод викликати то ми вмкористовуемо
    інтерфейси щоб специфікувати які методи будуть у класа також можно специфікувати (where) за
    class(усі ссилочні) struct(усі стракти) baseClassName interfaceName і new () мае бути публічний
    конструктор без параметрів
6. Поясніть призначення оператору default та його обмеження.
    оператор default(Type*) використовуеться для создания дефолтного типу де
    Type* це тип загалом використовують щоб проініцілізувати поле у дженеріках це нам треба бо
    якщо мі не вказаоли where T : new () зробити новий класс цього проте T t = default(T) зможемо
    воно завжди будет повертати нульове значення і змінити це не можно тобо для bool => false string => null
    int => null class(reference) => null  struct => всі поля по дефолту втсановляться ітд
    навіщо надо => оскільни ніяк ми екзмепляр новий дженеріковий создати не зможемо в класі самому бо
    навіть якщо проінілізувати нулл то треба буде писати where T : baseClassName бо буде помитка з
    типами що у стеку живуть то для цього нам і треба default(T)
7. Розкажіть про лямбда вирази. Наведіть приклад використання
лямбда-виразу.
    Лямбда вираз це анонімна функція тa синтаксичний сахар
    private void UpdateVersion() => Version++; list1.Where(x => x % 2 == 0);
    Самое головне что область бачимості інша у лямбда функцій аніж у звичайних функцій тоесть она может
    захопити у себе в тілі наприклад int потім її кудись передать і вона всеодно зможе змінювати int i
    який у іншій видимості і взагалі не референс тайп і це дуже зручно при розробці UI на кліентах коли
    ми можемо знизу напряму змінювати данні зверху Взагалі лямбда дуже зручно корстуватия як анонімними
    функціями оскільки зручний синтаксис. Можуть приймати як безліч так і 0 параметрів () =>
8. Розкрийте різниці між expression & statement лямбдами.
    Expression лямбда — це лямбда-вираз, який складається з одного виразу. Результат виконання виразу
    автоматично повертається. Приклад: private void UpdateVersion() => Version++;
    Statement лямбда — це лямбда-вираз, який складається з блоку коду, що містить декілька операторів.
    Повернення значення вимагає використання оператора return. Приклад:
    Func<int,int> doubleInt = x => { return x * 2 }
9. Розкажіть про події, і як вони реалізовані в С#.
    події в шарпах реалізовані через ключове слово event синтаксис такий
    public event delegateName EventName; також якщо потрібно якось валідувати евенти які вішають то
    public event delegateName EventName{ add => Event += value; remove { EventName -= value; } }
    делегат визначае сигнатуру делегатів які можно будет повісити на евент часто використовують
    public delegate void EventHandler(object sender, EventArgs e); на евенти також можно вішати
    методи які будуть повертати дані (Func<T>) і щоб отримати ретурни треба буде юзати myEv.GetInvocationList()
    який нам поверне весь список навішаних делегатів і ми пройдемося по списку і зможемо визивати та отримувати дані
    але так роблять дуже рідко бо івенти використовуюють щоб сповістити про подію також важливо сказали
    що можно реалізувати поведінку евентів і через делегати бо евенти так то на них і базуються але тоді
    всі хто отримали ссилку зможуть викликати Invoke() і буде не дуже гарно тому евенти можна викликати лише
    у класі де їх создали або у нащадках
10.Поясніть, яким чином виконується підписання на події та скасування
підписки.
    дуже просто допустим у нас е референс на івент myEvent і ми хочему при срабатованіі івенту робити звук
    myEvent += (object s, EventArgs e) => makeNoise(); доречі тут += визивает add просто так переписати всі
    подіїї myEvent = (object s, EventArgs e) => makeNoise(); ми не зможемо буде помилка
    щоб відписатися треба мати референс на делегат який ви хочете відписати тому як от я ввише дописав анонімну
    функцію (також можна new DelegateClassName(delegate(){})) відписати її я вже не зможу тому якщо потім потрібно
    буде відписуватися від події краще заранее делегат зробити myEvent -= DelegateName;
11.Наведіть склад класу делегату та поясніть, чим забезпечується
контроль типів в делегатах.
    public delegate void MyDelegate(int i); котнроль типів забзпечуеться сигнатурою деелгата в данному випидку
    сюди можно додати референси тільки на методи які повертають void та приймають параметр один параметр int
    якщо піхати щось інше компілятор помилку видасть
    взагалі синтаксис ось такий => public delegate void MyDelegate(int i); але якщо створювати свій делегат нам
    не хочеться модему взяти готові наприклад Action<T> т це аргументи і він завжди void є ще
    Func<T,TRes> і тут ретурн тільки один вкінці може бути до 16Т (там багато овердрайвів взагалі) але
    найголовніше розуміти що це все ті ж деелгати