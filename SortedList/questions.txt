1. Дайте визначання колекції. Як колекція пов’язана з інтерфейсами
IEnumerable та ICollection?
    Колекція це певвна структура данних що зберігає дані у певний спосіб. Дані однакові
    але спосіб для кожної колекції вірдрізняеться. Всі колекції у c# їх імплементують.
    Інтерфейс ICollection наслідуе інтерфейс IEnumerable. Приклад Фішок які ці інтерфейси дають класам
    IEnumerable дозволяе використовувати foreach також багато різних інших методів будуть працювати на класах,
    що реалізували цей інтерфейс наприклад методи з LINQ як Where Add First ітд
    ICollection це базовий інтерфейс для усіх колекцій ну наприклад він дозволяе (метод Add) робити так
    var collection = new YourCollection<Item>() {Item a, Item b} тобто добавляти елементи при ініціалізації
2. Розкажіть про основні інтерфейси необхідні для функціонування
колекцій та LINQ.
    основні інтерфейси для функціювання колекцій це ICollection IList IDictionary
    для LINQ IQueryable (наслідуе IEnumerable) та QueryProvider (його повертае метод провайдер інтерфейсу Iqueryable)
    по простому: IQueariable ынтрефей що дозволяе робити LINQ запроси а провайдер забезпечуе що цы запроси будуть працювати
    там де потрібно (наприклад з EF XML обьектами тобто у різних середовищах)
3. Розкажіть про призначення і можливі сценарії застосування
    Основне призначення інтерфейсу IEnumerator це дозволяти перебрати дані класом значення
    Енумератор повинен мати T Current() bool MoveNext() та voidReset() але останній советують
    не імпоементувати і замість нього кидати NoImplementedException.
    Основний сценарій застосування це перебір значень за допомогою foreach та реалізація власної колекції
    у звичайному випадку його самостійно не імплементують а використовують синкасчний цукор ( ключове слово yield )
4. Порівняйте інтерфейси IEnumerable та IAsyncEnumerable.
    Асинхронний енумератор також використовуеться для перебору значень але вже працюе асинхронно
    Зазвичай вони використовуються в різних сценаріях: всинхронний енумратор використовуеться лише коли
    треба асинхронність зазвчивай це у мережевих операціях або у дуже ресурсоемких операціях які можуть тривати
    певний час. для перебору використовують await foreach (var varianle in someFunction()){ }
    він також має Current та MoveNextAsync Reset вже не мае для перебору використовуеться async foreach
    мінуси такіж як і у асинхронних функцій - потенційні проблеми з конкуренціею та складність також треба
    більше ресурсів тому краще використовувати тільк при потребі
5. Розкажіть про призначення і обмеження generic типів.
    Дженерікі (Generic Types) общі типи прийшли на заміну старому порядку тобто використанню класа object та
    запакування в нього та розпакування з нього. Само тому старі імплементації олекцій не мають женеріків
    і мають object. Основна проблема що вирішив дженерік тайп це те що ми будемо отримувати помилку не у
    рантаймі коли ми развернемо обжект а там не зрозмуло що і не зрозуміло чому воно там, а ми просто
    отримаемо помилку компілятора який скаже що це туди не підходить. Також це менше коду писать бо нам
    не треба обробляти анбоксинг та захищати його від помилок. Основним обмеженням е те що ми не знаемо
    що це за тип для нас це тип T або U (TU ітд) і тому по дефолту будуть лише доступні методи обжекста
    тобто ToString Equals ітд... І наприклад коли нам треба якийсь метод викликати то ми вмкористовуемо
    інтерфейси щоб специфікувати які методи будуть у класа також можно специфікувати (where) за
    class(усі ссилочні) struct(усі стракти) baseClassName interfaceName і new () мае бути публічний
    конструктор без параметрів
6. Поясніть призначення оператору default та його обмеження.
    оператор default(Type*) використовуеться для создания дефолтного типу де
    Type* це тип загалом використовують щоб проініцілізувати поле у дженеріках це нам треба бо
    якщо мі не вказаоли where T : new () зробити новий класс цього проте T t = default(T) зможемо
    воно завжди будет повертати нульове значення і змінити це не можно тобо для bool => false string => null
    int => null class(reference) => null  struct => всі поля по дефолту втсановляться ітд
    навіщо надо => оскільни ніяк ми екзмепляр новий дженеріковий создати не зможемо в класі самому бо
    навіть якщо проінілізувати нулл то треба буде писати where T : baseClassName бо буде помитка з
    типами що у стеку живуть то для цього нам і треба default(T)

//TODO ДОРОБИТИ ПИТАННЯ
7. Розкажіть про лямбда вирази. Наведіть приклад використання
лямбда-виразу.
    Лямбда вираз це анонімна функція
    private void UpdateVersion() => Version++; list1.Where(x => x % 2 == 0);

8. Розкрийте різниці між expression & statement лямбдами.
    Expression лямбда — це лямбда-вираз, який складається з одного виразу. Результат виконання виразу
    автоматично повертається. Приклад: private void UpdateVersion() => Version++;
    Statement лямбда — це лямбда-вираз, який складається з блоку коду, що містить декілька операторів.
    Повернення значення вимагає використання оператора return. Приклад:
9. Розкажіть про події, і як вони реалізовані в С#.
10.Поясніть, яким чином виконується підписання на події та скасування
підписки.
11.Наведіть склад класу делегату та поясніть, чим забезпечується
контроль типів в делегатах.